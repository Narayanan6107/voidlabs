<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOIDLABS.inc</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.background = new THREE.Color(0x000000);

        const textureLoader = new THREE.TextureLoader();
        const floorTexture = textureLoader.load('floor_texture.jpg');
        floorTexture.wrapS = THREE.RepeatWrapping;
        floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(5, 5);

        const floorGeometry = new THREE.BoxGeometry(20, 2, 40);
        const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.y = -2;
        scene.add(floor);

        const wallTexture = textureLoader.load('wall_texture.jpg');
        wallTexture.wrapS = THREE.RepeatWrapping;
        wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.anisotropy = 16;
        wallTexture.repeat.set(1, 1);

        const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture });

        // Walls
        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(2, 10, 40), wallMaterial);
        leftWall.position.set(-10, 3, 0);
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(2, 10, 40), wallMaterial);
        rightWall.position.set(10, 3, 0);
        scene.add(rightWall);

        const frontWall = new THREE.Mesh(new THREE.BoxGeometry(20, 10, 2), wallMaterial);
        frontWall.position.set(0, 3, -20);
        scene.add(frontWall);

        const backWall = new THREE.Mesh(new THREE.BoxGeometry(20, 10, 2), wallMaterial);
        backWall.position.set(0, 3, 20);
        scene.add(backWall);
// ceiling 
        const ceilingTexture = textureLoader.load('cling.jpg');
ceilingTexture.wrapS = THREE.RepeatWrapping;
ceilingTexture.wrapT = THREE.RepeatWrapping;
ceilingTexture.anisotropy = 16;
ceilingTexture.repeat.set(4, 4);  // Adjust tiling

const ceilingMaterial = new THREE.MeshStandardMaterial({ 
    map: ceilingTexture, 
    side: THREE.DoubleSide 
});


const ceilingGeometry = new THREE.PlaneGeometry(40, 50);
const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
ceiling.rotation.x = Math.PI / 2; // Rotate to be horizontal
ceiling.position.set(2, 8, 2);
scene.add(ceiling);


const ambientLight = new THREE.AmbientLight(0xffffff, 1);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
directionalLight.position.set(10, 10, 10);
scene.add(directionalLight);

        // Pickable object
        const pickableObject = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
        pickableObject.position.set(0, 1, -3);
        scene.add(pickableObject);

        // 3D button
        const buttonGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.1);
        const buttonMaterial = new THREE.MeshBasicMaterial({ color: 0x4CAF50 });
        const button = new THREE.Mesh(buttonGeometry, buttonMaterial);
        button.position.set(2.5, 1, -19);
        scene.add(button);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isHoldingObject = false;
        let heldObject = null;

        window.addEventListener('keydown', (event) => {
            if (event.key.toLowerCase() === 'e') {
                if (!isHoldingObject) {
                    raycaster.set(camera.position, new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion));
                    const intersects = raycaster.intersectObject(pickableObject);
                    if (intersects.length > 0) {
                        isHoldingObject = true;
                        heldObject = pickableObject;
                        scene.remove(pickableObject);
                        camera.add(heldObject);
                        heldObject.position.set(0, 0, -2);
                    }
                } else {
                    isHoldingObject = false;
                    camera.remove(heldObject);
                    heldObject.position.set(
                        camera.position.x + camera.getWorldDirection(new THREE.Vector3()).x * 2,
                        camera.position.y,
                        camera.position.z + camera.getWorldDirection(new THREE.Vector3()).z * 2
                    );
                    scene.add(heldObject);
                    heldObject = null;
                }
            }
        });

        // Camera position
        camera.position.set(0, 1, 5);
        const speed = 0.3;
        const jumpSpeed = 0.09;
        let velocityY = 0;
        let isJumping = false;
        const keys = { w: false, a: false, s: false, d: false, space: false };
        let isMouseDown = false;
        let previousMouseX = 0;
        const rotationSpeed = 0.005;

        // Keyboard
        window.addEventListener('keydown', (event) => {
            if (event.code === 'Space' && !isJumping) {
                velocityY = jumpSpeed;
                isJumping = true;
            }
            keys[event.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (event) => { keys[event.key.toLowerCase()] = false; });

        // Mouse
        window.addEventListener('mousedown', (event) => { isMouseDown = true; previousMouseX = event.clientX; });
        window.addEventListener('mouseup', () => { isMouseDown = false; });
        window.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                camera.rotation.y -= (event.clientX - previousMouseX) * rotationSpeed;
                previousMouseX = event.clientX;
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const right = new THREE.Vector3().crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();
            if (keys.w) camera.position.addScaledVector(direction, speed);
            if (keys.s) camera.position.addScaledVector(direction, -speed);
            if (keys.a) camera.position.addScaledVector(right, -speed);
            if (keys.d) camera.position.addScaledVector(right, speed);
            camera.position.y += velocityY;
            if (isJumping) velocityY -= 0.004;
            if (camera.position.y <= 1) { camera.position.y = 1; isJumping = false; }
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
